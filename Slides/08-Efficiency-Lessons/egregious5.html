<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="UTF-8">
<meta name="description" content="Northeastern University CS 5010">
<meta name="author" content="William D Clinger">
<!-- meta name="keywords" content="software" -->

<title>
  Aggregate Update Problem
</title>

<link type="text/css"
      rel="stylesheet"
      href="cs5010.css" />

</head>

<body>

<!-- start of specific content -->

<div id="maincontent">
  <h3>
    Aggregate Update Problem
  </h3>
  <div>
    <p>
      The <code>concatenate</code> example might make you think
      purely functional programming is less efficient than
      imperative programming with side effects, and there's
      some truth in that.
    </p>
    <p>
      Purely functional programming suffers from the
      <em>aggregate update problem</em>: creating a new version
      of some large object that is only slightly different from
      the previous version is usually slower than modifying the
      large object by changing its state.
    </p>
    <p>
      On the other hand, modifying a large object by changing
      its state has the effect of destroying its previous state.
      If there are any parts of a program that still need that
      previous state, they'll have to copy that state before
      it's clobbered by some side effect.
    </p>
    <p>
      Imperative programming by side effect can therefore lead
      to excessive precautionary copying of large objects,
      while a purely functional programming paradigm can lead
      to excessive creation of large objects.
      Both outcomes are bad for efficiency.
    </p>
    <p>
      Functional programming makes it easier for large data
      structures to share representations of substructure,
      which can improve both time and space efficiency.
      The aggregate update problem can sometimes be avoided
      through clever sharing of substructure.
    </p>
    <p>
      In many cases, however, imperative updating of large
      data structures via side effects will be faster than
      a purely functional approach.
    </p>
    <p>
      There is no hard-and-fast rule that can tell you which
      paradigm will be fastest.
      That will depend on the particular program and its
      design, especially the design of its data structures.
    </p>
    <p>
      We'll have more to say about this toward the end of the
      semester.
    </p>
  </div>
</div>
<div id="footer">
  <form action="egregious4.html" class="inline">
    <input type="submit" value="PREV">
  </form>
  <br />
  <form action="summary2.html" class="inline">
    <input type="submit" value="NEXT">
  </form>
</div>

<!-- end of specific content -->

<p class="muchsmaller">
For debugging: 
<a href="http://validator.w3.org/check/referer">
Click here to validate.
</a>
</p>

</body>
</html>
